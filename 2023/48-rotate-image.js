/**
 * @param {number[][]} M
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function (M) {
    let n = M.length

    // 邊長除以 2 取整數。EX: ~~(3 / 2) = 1
    let depth = ~~(n / 2);

    for (let i = 0; i < depth; i++) {
        // `len` 變數表示每一層的長度。
        let len = n - 2 * i - 1;

        // 表示與 `i` 相對的索引位置，用來進行矩陣元素的旋轉。
        // 舉例來說：(0,0) 的 opposite 為 (0,2)
        let opp = n - 1 - i;

        for (let j = 0; j < len; j++) {
            let temp = M[i][i + j]
            M[i][i + j] = M[opp - j][i]
            M[opp - j][i] = M[opp][opp - j]
            M[opp][opp - j] = M[i + j][opp]
            M[i + j][opp] = temp
        }
    }
};

console.log(rotate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]));

/**
這段程式碼實現了一個矩陣旋轉的功能。以下是程式碼的邏輯解釋：
1. `rotate` 函式接受一個矩陣 `M` 作為參數。
2. `n` 變數代表矩陣 `M` 的邊長，即矩陣的維度。
   `~~(n / 2)` 表示將邊長除以 2 取整數，這裡使用位元運算子 `~~` 來執行此操作。
   `depth` 變數代表矩陣旋轉的層數，通常是邊長的一半。
3. 使用兩個巢狀的 `for` 迴圈來執行矩陣旋轉的過程。外層迴圈 `i` 從 0 開始，直到 `depth-1` 結束。
   這個迴圈用來控制旋轉的層數。
4. 在每一層中，內層迴圈 `j` 從 0 開始，直到 `len-1` 結束。
   `len` 變數表示每一層的長度，初始值為矩陣邊長減去兩倍的 `i`，因為每一層旋轉都會使矩陣的邊長減小。
5. 在內層迴圈中，進行矩陣元素的旋轉。`temp` 變數用來暫存要旋轉的元素。以下是旋轉的步驟：
   - 將 `M[i][i+j]` 的元素存入 `temp`。
   - 將 `M[opp-j][i]` 的元素移到 `M[i][i+j]` 的位置。
   - 將 `M[opp][opp-j]` 的元素移到 `M[opp-j][i]` 的位置。
   - 將 `M[i+j][opp]` 的元素移到 `M[opp][opp-j]` 的位置。
   - 將 `temp` 中的值存入 `M[i+j][opp]` 的位置，完成旋轉。
6. 當外層迴圈結束後，矩陣 `M` 就完成了旋轉操作，並且在原地進行了旋轉。


`opp` 是在程式碼中定義的一個變數，代表 "opposite"（相對的）的意思。它用於表示與 `i` 相對的索引位置，用來進行矩陣元素的旋轉。
在程式碼中，`opp` 的值是根據 `n`（矩陣邊長）和 `i`（層數）計算得來的。
具體來說，`opp` 的計算方式是 `n - 1 - i`，即將矩陣邊長減去 1 再減去層數 `i`。
這是因為在每一層旋轉中，元素的相對位置是成對的，對應的位置是 `i` 和 `opp`。
通過使用 `opp`，可以方便地存取和交換對應位置的元素，從而實現矩陣的旋轉操作。
*/
